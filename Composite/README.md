# Composite pattern
그릇과 내용물을 동일시 하여 재귀적인 구조를 만들기 위한 디자인 패턴이다. 
사용자로 하여금 개별 객체와 복합 객체를 모두 동일하게 다룰 수 있도록 하는 패턴이다.

## 문제 
- 객체간의 부모와 자식 관계가 있고 자식이 다시 부모가 되어 자식을 포함하는 구조의 프로그램인 경우 
이 구조를 사용하는 사용자 입장에서는 부모 객체와 자식 객체를 구분하고 처리를 다르게 하는 분기 처리가 필요하다.

## 활용성 
- 부분-전체의 객체 계통을 표현하고 싶을 때 사용한다.
- 사용자가 객체의 합성으로 생긴 복합 객체와 개개의 객체 사이의 차이를 알지 않고도 자기 일을 할 수 있도록 만들고 싶을 때 사용한다.

## 참여자 
- Component :  composite과 leaf의 공통 인터페이스를 정의한다. 사용자가 실제로 사용하는 참여자이다. 
- Leaf : 내용물을 나타내는 역할을 하는 객체로 가장 말단에 있는 객체로 자식이 없는 객체를 의미한다. 
- Composite : 그릇의 역할을 하는 객체로 하위에 자식이 있는 구성요소에 대한 행동을 정의한다. 
- Client : Component 인터페이스를 사용하여 개별 객체와 복합 객체를 조작한다. 

## 구현 시 고려사항 

### 포함 객체에 대한 명확한 참조자 
자식 구성요소에서 부모를 가리키는 참조자를 관리하면 복합체의 구조 관리를 단순화 할 수 있다. 
-> 책임 연산 패턴을 사용

### 구성 요소 공유 
자식이 여러 부모를 갖게 하여 구성요소를 공유한다. -> 플라이급 패턴 사용
 
### component 인터페이스를 최소화 

#### 문제
component에서 composite은 필요하지만 leaf가 사용하지 않는 연산을 정의할 수도 있다. 
자식을 관리하는 연산이 그러하다. leaf 클래스는 자식이 없는 구성요소로 자식을 관리하는 연산을 필요로하지 않는다. 
그러나 composite 클래스는 자식을 담는 역할을 하기 때문에 자식을 관리하는 연산을 필요로 한다. 

### 어떻게 하지???
이 문제는 인터페이스의 투명성과 안전성 사이에서 고민해야 한다.
- **component에 자식을 관리하는 연산을 추가한다. -> 인터페이스의 투명성을 보장하는 경우**  
: 인터페이스의 투명성은 보장하지만 leaf 클래스에서 자식을 관리하는 연산을 호출할 경우 오류가 발생한다. 
이에 대한 처리가 구현되어 있어야 한다.

- **composite에만 자식을 관리하는 연산을 추가한다. -> 인터페이스의 안전성을 보장하는 경우**   
: leaf 클래스 에서는 자식을 관리하는 연산을 호출할 수 없기 때문에 안전성은 보장 받지만 서로 다른 인터페이스를 갖게 되므로 
사용자는 동일한 대상을 사용한다고 간주할 수 없다. 
이에 대한 해결 방안으로 component에 기본적으로는 null을 반환하고 composite일 경우 composite 자신을 반환하는 연산을 정의하고
반환하는 결과 값에 따라서 연산을 수행할 수 있는 대상인지 검사 후에 연산을 요청한다. 그러나 이 방법은 확장성 측면에서 바람직하지 않다.

## 결과 
- composite pattern을 사용함으로 사용자 부모와 자식 구별하지 않고 동일하게 처리할 수 있도록 한다. 
이를 통해 객체를 구분하고 처리를 다르게 하는 분기 처리를 제거할 수 있기 때문에 사용자의 코드가 단순해 진다. 
- 기본 클래스와 이들의 컨테이너를 모두 표현할 수 있는 하나의 추상화 클래스를 사용하기 때문에 새로운 종류의
구성요소를 쉽게 추가할 수 있다. 
- 새로운 요소를 쉽게 추가할 수 있기 때문에 구성요소에 제약을 가하기 힘들다는 단점이 있다. 
 